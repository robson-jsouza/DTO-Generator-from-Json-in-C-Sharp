// Program.cs
using System.Text.Json;

namespace ClassFromJson.TsGen;

internal static class Program
{
    static int Main(string[] args)
    {
        // args: --input <dir> --out <dir>
        string input = "", output = "";
        for (int i = 0; i < args.Length; i++)
        {
            if (args[i] == "--input" && i + 1 < args.Length) input = args[++i];
            else if (args[i] == "--out" && i + 1 < args.Length) output = args[++i];
        }

        if (string.IsNullOrWhiteSpace(input) || string.IsNullOrWhiteSpace(output))
        {
            Console.Error.WriteLine("Usage: --input <dir> --out <dir>");
            return 1;
        }

        return Run(Path.GetFullPath(input), Path.GetFullPath(output));
    }

    private static string GenTs(Spec s)
    {
        var sb = new System.Text.StringBuilder();

        sb.AppendLine("// <auto-generated from .class.json>");
        sb.AppendLine($"// Namespace: {s.Namespace}");

        // ----- imports for complex types used in property initializers -----
        var imports = new HashSet<string>(StringComparer.Ordinal);
        foreach (var p in s.Properties)
        {
            var import = TryGetImportType(p.Type);
            if (import is not null && import != s.Class) imports.Add(import);
        }
        foreach (var imp in imports)
            sb.AppendLine($"import {{ {imp} }} from './{ToKebab(imp).ToLowerInvariant()}';");

        // ----- class -----
        sb.AppendLine($"export class {s.Class} {{");

        foreach (var p in s.Properties)
        {
            var tsName = char.ToLowerInvariant(p.Name[0]) + p.Name[1..];
            var tsType = TsTypeFor(p.Type);
            var init = TsDefaultInitFor(p.Type);
            sb.AppendLine($"  {tsName}: {tsType} = {init};");
        }

        sb.AppendLine();
        sb.AppendLine($"  constructor(init?: Partial<{s.Class}>) {{");
        sb.AppendLine("    Object.assign(this, init);");

        // Normalize dates passed as ISO strings at runtime
        foreach (var p in s.Properties)
        {
            var tsName = char.ToLowerInvariant(p.Name[0]) + p.Name[1..];
            var baseType = p.Type.TrimEnd('?').Trim();
            if (baseType is "DateTime" or "DateOnly")
                sb.AppendLine($"    if (typeof this.{tsName} === 'string') this.{tsName} = new Date(this.{tsName} as unknown as string);");
        }

        sb.AppendLine("  }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static Spec Parse(string path)
    {
        using var doc = JsonDocument.Parse(File.ReadAllText(path));
        var root = doc.RootElement;

        string ns = root.GetProperty("namespace").GetString()!;
        string cls = root.GetProperty("class").GetString()!;
        var props = new List<Prop>();
        foreach (var p in root.GetProperty("properties").EnumerateArray())
        {
            string name = p.GetProperty("name").GetString()!;
            string type = p.GetProperty("type").GetString()!;
            string? de = p.TryGetProperty("defaultExpression", out var dex) ? dex.GetString() : null;
            JsonElement? d = p.TryGetProperty("default", out var dv) ? dv : null;
            props.Add(new Prop(name, type, de, d));
        }
        return new Spec(ns, cls, props);
    }

    private static int Run(string inputDir, string outDir)
    {
        Directory.CreateDirectory(outDir);
        foreach (var file in Directory.EnumerateFiles(inputDir, "*.class.json", SearchOption.AllDirectories))
        {
            var spec = Parse(file);
            var ts = GenTs(spec);
            var outPath = Path.Combine(outDir, $"{ToKebab(spec.Class).ToLowerInvariant()}.ts");
            File.WriteAllText(outPath, ts);
            Console.WriteLine($"Wrote {outPath}");
        }
        return 0;
    }

    private static string ToKebab(string s)
    {
        if (string.IsNullOrEmpty(s)) return s;
        var sb = new System.Text.StringBuilder(s.Length + 8);
        for (int i = 0; i < s.Length; i++)
        {
            char c = s[i];
            if (char.IsUpper(c))
            {
                // insert dash if previous is lower/digit OR next is lower (handles acronyms)
                if (i > 0 && (char.IsLower(s[i - 1]) || char.IsDigit(s[i - 1]) ||
                              (i + 1 < s.Length && char.IsLower(s[i + 1]))))
                    sb.Append('-');
                sb.Append(char.ToLowerInvariant(c));
            }
            else if (c == '.' || c == '_' || c == ' ')
            {
                sb.Append('-');
            }
            else
            {
                sb.Append(char.ToLowerInvariant(c));
            }
        }
        return sb.ToString();
    }

    // If a complex type needs an import for its initializer, return its name
    private static string? TryGetImportType(string csType)
    {
        var t = csType.Trim();
        var nullable = t.EndsWith("?");
        t = t.TrimEnd('?');

        // arrays don't need imports for initializers (=[]). Drill down to element type
        if (t.StartsWith("List<") && t.EndsWith(">")) return TryGetImportType(t[5..^1]);

        // primitives/date → no import
        if (t is "string" or "bool" or "byte" or "sbyte" or "short" or "ushort" or
                "int" or "uint" or "long" or "ulong" or "nint" or "nuint" or
                "float" or "double" or "decimal" or "DateTime" or "DateOnly")
            return null;

        // complex type name
        return nullable ? null : t;
    }

    // Default initializer for the property (matches nullability)
    private static string TsDefaultInitFor(string csType)
    {
        var t = csType.Trim();
        var nullable = t.EndsWith("?");
        t = t.TrimEnd('?');

        if (nullable) return "null";

        return t switch
        {
            "string" => "''",
            "bool" => "false",
            "byte" or "sbyte" or "short" or "ushort" or "int" or "uint" or "long" or "ulong" or
            "nint" or "nuint" or "float" or "double" or "decimal" => "0",
            "DateTime" or "DateOnly" => "new Date()",
            _ when t.StartsWith("List<") && t.EndsWith(">") => "[]",
            _ => $"new {t}()" // complex type → new instance + import
        };
    }

    private static string TsType(string csType)
    {
        var t = csType.Trim();
        var nullable = t.EndsWith("?");
        t = t.TrimEnd('?');

        string core = t switch
        {
            "string" => "string",
            "bool" => "boolean",
            "byte" or "sbyte" or "short" or "ushort" or "int" or "uint" or "long" or "ulong" or
            "nint" or "nuint" or "float" or "double" or "decimal" => "number",
            "DateTime" or "DateOnly" => "Date",
            _ when t.StartsWith("List<") && t.EndsWith(">") => $"{TsType(t[5..^1])}[]",
            _ => t // assume complex type maps 1:1
        };
        return nullable ? $"{core} | null" : core;
    }

    // TS type string (with | null when C# is nullable)
    private static string TsTypeFor(string csType)
    {
        var t = csType.Trim();
        var nullable = t.EndsWith("?");
        t = t.TrimEnd('?');

        string core = t switch
        {
            "string" => "string",
            "bool" => "boolean",
            "byte" or "sbyte" or "short" or "ushort" or "int" or "uint" or "long" or "ulong" or
            "nint" or "nuint" or "float" or "double" or "decimal" => "number",
            "DateTime" or "DateOnly" => "Date",
            _ when t.StartsWith("List<") && t.EndsWith(">") => $"{TsTypeFor(t[5..^1])}[]",
            _ => t // complex type name maps 1:1
        };

        return nullable ? $"{core} | null" : core;
    }
}

internal readonly record struct Prop(string Name, string Type, string? DefaultExpression, JsonElement? Default);
internal sealed record Spec(string Namespace, string Class, List<Prop> Properties);
