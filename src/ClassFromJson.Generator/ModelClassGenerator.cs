#nullable enable
// <auto-generated/>
// Dependency-free source generator: parses simple JSON without external packages.
// Copyright (c) You
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace ClassFromJson.Generator;

[Generator(LanguageNames.CSharp)]
public sealed class ModelClassGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var jsonFiles = context.AdditionalTextsProvider
            .Where(a => a.Path.EndsWith(".class.json", StringComparison.OrdinalIgnoreCase))
            .Select((text, ct) =>
            {
                var content = text.GetText(ct)?.ToString() ?? "";
                return new JsonSpecFile(text.Path, content);
            });

        context.RegisterSourceOutput(jsonFiles, (spc, file) =>
        {
            if (string.IsNullOrWhiteSpace(file.Content)) return;

            try
            {
                var spec = Parse(file.Content, file.Path);
                var source = GenerateSource(spec);
                var hintName = MakeHintName(spec);
                spc.AddSource(hintName, SourceText.From(source, Encoding.UTF8));
            }
            catch (Exception ex)
            {
                spc.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor(
                        id: "CFJ001",
                        title: "ClassFromJson generation error",
                        messageFormat: "Error generating from '{0}': {1}",
                        category: "ClassFromJson",
                        DiagnosticSeverity.Warning,
                        isEnabledByDefault: true),
                    Location.None,
                    file.Path, ex.Message));
            }
        });
    }

    private static string MakeHintName(ClassSpec spec)
        => $"{spec.Namespace}.{spec.ClassName}.g.cs".Replace('.', '_');

    private static ClassSpec Parse(string json, string path)
    {
        var root = MiniJson.Parse(json) as Dictionary<string, object?>;
        if (root is null) throw new InvalidOperationException($"Invalid JSON in {path}");

        string ns = RequiredString(root, "namespace", path);
        string className = RequiredString(root, "class", path);

        string accessibility = (TryGetString(root, "accessibility") ?? "public").Trim();
        bool isSealed = TryGetBool(root, "sealed") ?? false;

        var usings = new List<string> { "System", "System.Collections.Generic" };
        if (root.TryGetValue("usings", out var usObj) && usObj is List<object?> usList)
        {
            foreach (var u in usList)
            {
                if (u is string s && !string.IsNullOrWhiteSpace(s)) usings.Add(s);
            }
        }
        usings = usings.Distinct(StringComparer.Ordinal).ToList();

        var props = new List<PropertySpec>();
        if (!root.TryGetValue("properties", out var propsObj) || propsObj is not List<object?> propsList)
            throw new InvalidOperationException($"Missing 'properties' in {path}");
        foreach (var pObj in propsList)
        {
            if (pObj is not Dictionary<string, object?> p)
                throw new InvalidOperationException($"Each property entry must be an object in {path}");

            string name = RequiredString(p, "name", path);
            string type = RequiredString(p, "type", path);
            string propAcc = (GetString(p, "accessibility") ?? "public").Trim();

            bool hasDefaultExpr = p.ContainsKey("defaultExpression");
            bool hasDefault = p.ContainsKey("default");

            string? defaultInitializer = null;
            if (hasDefaultExpr)
            {
                defaultInitializer = GetString(p, "defaultExpression");
            }
            else if (hasDefault)
            {
                if (!p.TryGetValue("default", out var dv))
                    throw new InvalidOperationException($"'default' must be present when specified in {path}");
                defaultInitializer = FromJsonLiteralToCSharp(dv, type);
            }

            props.Add(new PropertySpec(name, type, propAcc, defaultInitializer));
        }

        return new ClassSpec(ns, className, accessibility, isSealed, usings, props);
    }

    private static string RequiredString(Dictionary<string, object?> dict, string key, string path)
    {
        if (!dict.TryGetValue(key, out var v) || v is null) throw new InvalidOperationException($"Missing '{key}' in {path}");
        var s = v as string;
        if (string.IsNullOrWhiteSpace(s)) throw new InvalidOperationException($"Empty '{key}' in {path}");
        return s;
    }

    private static string? TryGetString(Dictionary<string, object?> dict, string key)
        => dict.TryGetValue(key, out var v) ? v as string : null;
    private static string? GetString(Dictionary<string, object?> dict, string key)
        => dict.TryGetValue(key, out var v) ? v as string : null;
    private static bool? TryGetBool(Dictionary<string, object?> dict, string key)
        => dict.TryGetValue(key, out var v) ? v as bool? : null;

    private static string FromJsonLiteralToCSharp(object? value, string type)
    {
        switch (value)
        {
            case null:
                if (IsNullableTypeString(type)) return "null";
                if (IsReferenceTypeString(type) && !IsNullableTypeString(type)) return "default!";
                return "default";
            case bool b:
                return b ? "true" : "false";
            case string s:
                return ToCSharpStringLiteral(s);
            case double d:
                // Preserve integers without .0 when possible
                if (Math.Abs(d % 1) < double.Epsilon) return ((long)d).ToString();
                return d.ToString(System.Globalization.CultureInfo.InvariantCulture);
            case long l:
                return l.ToString();
            case int i:
                return i.ToString();
            default:
                throw new InvalidOperationException($"Unsupported JSON default literal for type '{type}'. Use 'defaultExpression' instead.");
        }
    }

    private static bool IsNullableTypeString(string type)
        => type.Trim().EndsWith("?");
    private static bool IsReferenceTypeString(string type)
    {
        var t = type.TrimEnd('?').Trim();
        var valueTypes = new HashSet<string>(StringComparer.Ordinal)
        {
            "bool","byte","sbyte","short","ushort","int","uint","long","ulong","nint","nuint",
            "float","double","decimal","char","DateTime","DateOnly","TimeOnly","Guid"
        };
        return !valueTypes.Contains(t) && !t.EndsWith("]", StringComparison.Ordinal);
    }
    private static string ToCSharpStringLiteral(string s)
    {
        s = s.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\r", "\\r").Replace("\n", "\\n").Replace("\t", "\\t");
        return $"\"{s}\"";
    }

    private static string GenerateSource(ClassSpec spec)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// Generated by ClassFromJson.Generator");
        foreach (var u in spec.Usings.Distinct().OrderBy(x => x, StringComparer.Ordinal))
            sb.AppendLine($"using {u};");
        sb.AppendLine();
        sb.AppendLine($"namespace {spec.Namespace};");
        sb.AppendLine();
        var sealedKw = spec.IsSealed ? " sealed" : "";
        sb.AppendLine($"{spec.Accessibility} partial class {spec.ClassName}{sealedKw}");
        sb.AppendLine("{");
        foreach (var p in spec.Properties)
        {
            var init = p.DefaultInitializer is null ? "" : $" = {p.DefaultInitializer};";
            sb.AppendLine($"    {p.Accessibility} {p.Type} {p.Name} {{ get; set; }}{init}");
        }
        sb.AppendLine("}");
        return sb.ToString();
    }

    private readonly record struct JsonSpecFile(string Path, string Content);

    private sealed record ClassSpec(
        string Namespace,
        string ClassName,
        string Accessibility,
        bool IsSealed,
        List<string> Usings,
        List<PropertySpec> Properties);

    private sealed record PropertySpec(
        string Name,
        string Type,
        string Accessibility,
        string? DefaultInitializer);
}

// Minimal JSON parser for our constrained schema (strings, numbers, bool, null, arrays, objects).
// Returns C# types: Dictionary<string, object?>, List<object?>, string, double (or long/int), bool, null.
internal static class MiniJson
{
    public static object? Parse(string json) => new Parser(json).ParseValue();

    private sealed class Parser
    {
        private readonly string _s;
        private int _i;
        public Parser(string s) { _s = s; _i = 0; }
        public object? ParseValue()
        {
            SkipWs();
            if (_i >= _s.Length) throw Error("Unexpected end of JSON");
            char c = _s[_i];
            switch (c)
            {
                case '{': return ParseObject();
                case '[': return ParseArray();
                case '"': return ParseString();
                case 't': return ParseTrue();
                case 'f': return ParseFalse();
                case 'n': return ParseNull();
                default: return ParseNumber();
            }
        }
        private Dictionary<string, object?> ParseObject()
        {
            Expect('{'); SkipWs();
            var dict = new Dictionary<string, object?>(StringComparer.Ordinal);
            if (Peek('}')) { _i++; return dict; }
            while (true)
            {
                SkipWs();
                string key = ParseString();
                SkipWs();
                Expect(':');
                var val = ParseValue();
                dict[key] = val;
                SkipWs();
                if (Peek('}')) { _i++; break; }
                Expect(',');
            }
            return dict;
        }
        private List<object?> ParseArray()
        {
            Expect('['); SkipWs();
            var list = new List<object?>();
            if (Peek(']')) { _i++; return list; }
            while (true)
            {
                var v = ParseValue();
                list.Add(v);
                SkipWs();
                if (Peek(']')) { _i++; break; }
                Expect(',');
            }
            return list;
        }
        private string ParseString()
        {
            Expect('"');
            var sb = new StringBuilder();
            while (_i < _s.Length)
            {
                char c = _s[_i++];
                if (c == '"') break;
                if (c == '\\')
                {
                    if (_i >= _s.Length) throw Error("Unterminated escape sequence");
                    char e = _s[_i++];
                    switch (e)
                    {
                        case '"': sb.Append('\"'); break;
                        case '\\': sb.Append('\\'); break;
                        case '/': sb.Append('/'); break;
                        case 'b': sb.Append('\b'); break;
                        case 'f': sb.Append('\f'); break;
                        case 'n': sb.Append('\n'); break;
                        case 'r': sb.Append('\r'); break;
                        case 't': sb.Append('\t'); break;
                        case 'u':
                            if (_i + 4 > _s.Length) throw Error("Invalid unicode escape");
                            var hex = _s.Substring(_i, 4);
                            if (!ushort.TryParse(hex, System.Globalization.NumberStyles.HexNumber, null, out var cp))
                                throw Error("Invalid unicode escape");
                            sb.Append((char)cp);
                            _i += 4;
                            break;
                        default: throw Error($"Invalid escape '\\{e}'");
                    }
                }
                else
                {
                    sb.Append(c);
                }
            }
            return sb.ToString();
        }
        private object? ParseNull() { Expect('n'); Expect('u'); Expect('l'); Expect('l'); return null; }
        private bool ParseTrue() { Expect('t'); Expect('r'); Expect('u'); Expect('e'); return true; }
        private bool ParseFalse() { Expect('f'); Expect('a'); Expect('l'); Expect('s'); Expect('e'); return false; }
        private object ParseNumber()
        {
            int start = _i;
            if (Peek('-')) _i++;
            while (_i < _s.Length && char.IsDigit(_s[_i])) _i++;
            bool hasFrac = false, hasExp = false;
            if (Peek('.')) { hasFrac = true; _i++; while (_i < _s.Length && char.IsDigit(_s[_i])) _i++; }
            if (Peek('e') || Peek('E'))
            { hasExp = true; _i++; if (Peek('+') || Peek('-')) _i++; while (_i < _s.Length && char.IsDigit(_s[_i])) _i++; }
            string num = _s.Substring(start, _i - start);
            if (!hasFrac && !hasExp && long.TryParse(num, out var l))
            {
                if (l >= int.MinValue && l <= int.MaxValue) return (int)l;
                return l;
            }
            if (double.TryParse(num, System.Globalization.NumberStyles.Float, System.Globalization.CultureInfo.InvariantCulture, out var d))
                return d;
            throw Error($"Invalid number '{num}'");
        }
        private void SkipWs()
        {
            while (_i < _s.Length && char.IsWhiteSpace(_s[_i])) _i++;
        }
        private void Expect(char c)
        {
            if (_i >= _s.Length || _s[_i] != c) throw Error($"Expected '{c}'");
            _i++;
        }
        private bool Peek(char c) => _i < _s.Length && _s[_i] == c;
        private Exception Error(string msg) => new InvalidOperationException($"{msg} at position {_i}");
    }
}
