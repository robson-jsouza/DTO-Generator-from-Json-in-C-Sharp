#nullable enable
// <auto-generated/>
// Copyright (c) You
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace ClassFromJson.Generator;

[Generator(LanguageNames.CSharp)]
public sealed class ModelClassGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var jsonFiles = context.AdditionalTextsProvider
            .Where(a => a.Path.EndsWith(".class.json", StringComparison.OrdinalIgnoreCase))
            .Select((text, ct) =>
            {
                var content = text.GetText(ct)?.ToString() ?? "";
                return new JsonSpecFile(text.Path, content);
            });

        context.RegisterSourceOutput(jsonFiles, (spc, file) =>
        {
            if (string.IsNullOrWhiteSpace(file.Content)) return;

            try
            {
                var spec = Parse(file.Content, file.Path);
                var source = GenerateSource(spec);
                var hintName = MakeHintName(spec);
                spc.AddSource(hintName, SourceText.From(source, Encoding.UTF8));
            }
            catch (Exception ex)
            {
                spc.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor(
                        id: "CFJ001",
                        title: "ClassFromJson generation error",
                        messageFormat: "Error generating from '{0}': {1}",
                        category: "ClassFromJson",
                        DiagnosticSeverity.Warning,
                        isEnabledByDefault: true),
                    Location.None,
                    file.Path, ex.Message));
            }
        });
    }

    private static string MakeHintName(ClassSpec spec)
        => $"{spec.Namespace}.{spec.ClassName}.g.cs".Replace('.', '_');

    private static ClassSpec Parse(string json, string path)
    {
        using var doc = JsonDocument.Parse(json);
        var root = doc.RootElement;

        string ns = Required(root, "namespace", path);
        string className = Required(root, "class", path);

        string accessibility = root.TryGetProperty("accessibility", out var accEl)
            ? accEl.GetString() ?? "public" : "public";

        bool isSealed = root.TryGetProperty("sealed", out var sealedEl) && sealedEl.GetBoolean();

        var usings = new List<string> { "System", "System.Collections.Generic" };
        if (root.TryGetProperty("usings", out var usEl) && usEl.ValueKind == JsonValueKind.Array)
        {
            foreach (var u in usEl.EnumerateArray())
            {
                var s = u.GetString();
                if (!string.IsNullOrWhiteSpace(s)) usings.Add(s!);
            }
        }
        usings = usings.Distinct().ToList();

        var props = new List<PropertySpec>();
        if (!root.TryGetProperty("properties", out var propsEl) || propsEl.ValueKind != JsonValueKind.Array)
            throw new InvalidOperationException($"Missing 'properties' in {path}");

        foreach (var p in propsEl.EnumerateArray())
        {
            string name = Required(p, "name", path);
            string type = Required(p, "type", path);
            string propAcc = p.TryGetProperty("accessibility", out var pacc) ? (pacc.GetString() ?? "public") : "public";

            string? defaultInitializer = null;

            if (p.TryGetProperty("defaultExpression", out var de))
            {
                defaultInitializer = de.GetString();
            }
            else if (p.TryGetProperty("default", out var dv))
            {
                defaultInitializer = FromJsonLiteralToCSharp(dv, type);
            }

            props.Add(new PropertySpec(name, type, propAcc, defaultInitializer));
        }

        return new ClassSpec(ns, className, accessibility, isSealed, usings, props);
    }

    private static string Required(JsonElement el, string name, string path)
    {
        if (!el.TryGetProperty(name, out var v) || v.ValueKind is JsonValueKind.Null or JsonValueKind.Undefined)
            throw new InvalidOperationException($"Missing '{name}' in {path}");
        var s = v.GetString();
        if (string.IsNullOrWhiteSpace(s)) throw new InvalidOperationException($"Empty '{name}' in {path}");
        return s!;
    }

    private static string FromJsonLiteralToCSharp(JsonElement value, string type)
    {
        switch (value.ValueKind)
        {
            case JsonValueKind.String:
                return ToCSharpStringLiteral(value.GetString() ?? "");
            case JsonValueKind.Number:
                return value.GetRawText(); // preserves 123 or 1.23
            case JsonValueKind.True:
            case JsonValueKind.False:
                return value.GetRawText();
            case JsonValueKind.Null:
                if (IsNullableTypeString(type)) return "null";
                if (IsReferenceTypeString(type) && !IsNullableTypeString(type)) return "default!";
                return "default";
            default:
                throw new InvalidOperationException($"Unsupported JSON default literal for type '{type}'. Use 'defaultExpression' instead.");
        }
    }

    private static bool IsNullableTypeString(string type)
        => type.Trim().EndsWith("?");

    private static bool IsReferenceTypeString(string type)
    {
        var t = type.TrimEnd('?').Trim();
        var valueTypes = new HashSet<string>(StringComparer.Ordinal)
        {
            "bool","byte","sbyte","short","ushort","int","uint","long","ulong","nint","nuint",
            "float","double","decimal","char","DateTime","DateOnly","TimeOnly","Guid"
        };
        return !valueTypes.Contains(t) && !t.EndsWith("]", StringComparison.Ordinal);
    }

    private static string ToCSharpStringLiteral(string s)
    {
        s = s.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\r", "\\r").Replace("\n", "\\n").Replace("\t", "\\t");
        return $"\"{s}\"";
    }

    private static string GenerateSource(ClassSpec spec)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// Generated by ClassFromJson.Generator");
        sb.AppendLine("#nullable enable");
        foreach (var u in spec.Usings.Distinct().OrderBy(x => x, StringComparer.Ordinal))
            sb.AppendLine($"using {u};");
        sb.AppendLine();
        sb.AppendLine($"namespace {spec.Namespace};");
        sb.AppendLine();
        var sealedKw = spec.IsSealed ? " sealed" : "";
        sb.AppendLine($"{spec.Accessibility} partial class {spec.ClassName}{sealedKw}");
        sb.AppendLine("{");
        foreach (var p in spec.Properties)
        {
            var init = p.DefaultInitializer is null ? "" : $" = {p.DefaultInitializer};";
            sb.AppendLine($"    {p.Accessibility} {p.Type} {p.Name} {{ get; set; }}{init}");
        }
        sb.AppendLine("}");
        return sb.ToString();
    }

    private readonly record struct JsonSpecFile(string Path, string Content);

    private sealed record ClassSpec(
        string Namespace,
        string ClassName,
        string Accessibility,
        bool IsSealed,
        List<string> Usings,
        List<PropertySpec> Properties);

    private sealed record PropertySpec(
        string Name,
        string Type,
        string Accessibility,
        string? DefaultInitializer);
}
